// Do not modify this file directly as it is auto-generated by `npm run build` command
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// rules/comment.js
var require_comment = __commonJS({
  "rules/comment.js"(exports2, module2) {
    var FORMAL = /^\s(HACK|TODO):(\s\S|$)/;
    var HACK = /^\s*(HACK|XXX)\W\s*/i;
    var TODO = /^\s*TODO\W\s*/i;
    var FIXME = /^\s*FIXME\W\s*/i;
    var NOTE = /^\s*(Note\W)\s/i;
    var URL = /^\s(?:See\s*:\s*)?(\w+:\/\/.+)/i;
    var ESLINT = /^eslint-(disable|enable)/;
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce starting a single-line comment with either `TODO:`, `HACK:`, `See {url}`, or a first-capitalized word"
        }
      },
      create: function(context) {
        return {
          Program: function(root) {
            const commentNodes = (root.comments || []).filter((node) => node.type === "Line");
            for (let index = 0; index <= commentNodes.length - 1; index++) {
              const node = commentNodes[index];
              if (!node.loc) {
                continue;
              }
              if (FORMAL.test(node.value)) {
                return null;
              }
              if (HACK.test(node.value)) {
                return context.report({
                  loc: node.loc,
                  message: `Expected the comment to be written as "HACK: ..."`
                });
              }
              if (TODO.test(node.value)) {
                return context.report({
                  loc: node.loc,
                  message: `Expected the comment to be written as "TODO: ..."`
                });
              }
              if (FIXME.test(node.value)) {
                return context.report({
                  loc: node.loc,
                  message: `Expected the comment to be written as "TODO: ..."`
                });
              }
              const [, url] = node.value.match(URL) || [];
              if (url) {
                return context.report({
                  loc: node.loc,
                  message: `Expected the comment to be written as "See ${url}"`
                });
              }
              const [, note] = node.value.match(NOTE) || [];
              if (NOTE.test(node.value)) {
                return context.report({
                  loc: node.loc,
                  message: `Unexpected "${note.trim()}"`
                });
              }
              if (index > 0 && node.loc.start.line === (commentNodes[index - 1].loc?.start.line ?? 0) + 1) {
                return null;
              }
              const text = node.value.trim();
              if (text.includes(" ") === false || ESLINT.test(text)) {
                return null;
              }
              const firstChar = text.charAt(0);
              if (firstChar !== firstChar.toUpperCase()) {
                return context.report({
                  loc: node.loc,
                  message: `Expected the comment to start with a capital letter`
                });
              }
            }
          }
        };
      },
      tests: void 0
    };
  }
});

// rules/export-name-after-file-name.js
var require_export_name_after_file_name = __commonJS({
  "rules/export-name-after-file-name.js"(exports2, module2) {
    var fp = require("path");
    var _ = require("lodash");
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce naming a default exported identifier after the file name"
        }
      },
      create: function(context) {
        return {
          ExportNamedDeclaration: function(root) {
            if (!root.source || root.source.type !== "Literal" || typeof root.source.value !== "string" || root.source.value.startsWith(".") === false) {
              return;
            }
            const defaultNode = root.specifiers.find((node) => _.isMatch(node, EXPORT_DEFAULT));
            if (!defaultNode) {
              return;
            }
            const defaultName = defaultNode.exported.name;
            if (defaultName === "default") {
              return;
            }
            const expectedName = fp.basename(root.source.value).replace(/\..*/, "");
            if (expectedName !== _.words(expectedName).join("")) {
              return;
            }
            if (defaultName !== expectedName) {
              context.report({
                node: defaultNode,
                message: `Expected the default export name "${defaultName}" to be after its file name "${expectedName}"`
              });
            }
          }
        };
      },
      tests: void 0
    };
    var EXPORT_DEFAULT = {
      type: "ExportSpecifier",
      local: {
        type: "Identifier",
        name: "default"
      },
      exported: {
        type: "Identifier"
      }
    };
  }
});

// rules/import-convention.js
var require_import_convention = __commonJS({
  "rules/import-convention.js"(exports2, module2) {
    var _ = require("lodash");
    var fs = require("fs");
    var fp = require("path");
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce naming imported identifiers after the user-defined list"
        },
        schema: {
          type: "array",
          items: {
            type: "object",
            properties: {
              path: { type: "string" }
            },
            additionalProperties: {
              default: { anyOf: [{ type: "boolean" }, { type: "string" }] },
              namespace: { anyOf: [{ type: "boolean" }, { type: "string" }] },
              named: {
                anyOf: [
                  { type: "boolean" },
                  {
                    type: "array",
                    items: {
                      type: "object",
                      properties: {
                        name: { type: "string" }
                      },
                      additionalProperties: {
                        rename: { type: "string" },
                        forbidden: { type: "boolean" }
                      }
                    }
                  }
                ]
              }
            }
          }
        }
      },
      create: function(context) {
        const rules = context.options.map(({ path, named, ...rest }) => ({
          ...rest,
          path: new RegExp(path),
          named: Array.isArray(named) ? named.map(({ name, ...rest2 }) => ({ ...rest2, name: new RegExp(name) })) : named
        }));
        function check({ root, modulePath, namespaceNode, defaultNode, namedWrappers }) {
          const rule = rules.find(({ path }) => path.test(modulePath));
          if (!rule) {
            return;
          }
          if (namespaceNode) {
            if (rule.namespace === false) {
              context.report({
                node: namespaceNode,
                message: `Unexpected the namespace import.`
              });
            }
            const actualName = namespaceNode.name;
            const expectedName = normalizeIdentifierName(
              typeof rule.namespace === "string" ? modulePath.replace(rule.path, rule.namespace) : actualName
            );
            if (actualName !== expectedName) {
              context.report({
                node: namespaceNode,
                message: `Expected the namespace import to be "${expectedName}".`
              });
            }
            return;
          } else if (rule.namespace === true && !rule.default) {
            context.report({
              node: root,
              message: `Expected the namespace import.`
            });
            return;
          }
          if (defaultNode) {
            if (rule.default === false) {
              context.report({
                node: defaultNode,
                message: `Unexpected the default import.`
              });
            }
            const actualName = defaultNode.name;
            const expectedName = normalizeIdentifierName((() => {
              if (typeof rule.default === "string") {
                return modulePath.replace(rule.path, rule.default);
              }
              if (rule.default === true && !modulePath.startsWith(".") && !modulePath.startsWith("/") && context.parserPath && context.parserPath.includes("@typescript-eslint/parser".replace("/", fp.sep))) {
                try {
                  const name = findType(modulePath, fp.dirname(context.filename));
                  if (name) {
                    return name;
                  }
                } catch {
                }
              }
              return actualName;
            })());
            if (actualName !== expectedName) {
              context.report({
                node: defaultNode,
                message: `Expected the default import to be "${expectedName}".`
              });
            }
            if ((rule.named === true || Array.isArray(rule.named)) && "parent" in defaultNode) {
              const parentNode = (
                /** @type {import('estree').Node} */
                defaultNode.parent
              );
              const accessors = _.compact(
                context.sourceCode.getDeclaredVariables(parentNode)[0].references.map((node) => {
                  const identifier = (
                    /** @type {import('eslint').Rule.Node} */
                    node.identifier
                  );
                  return identifier.parent.type === "MemberExpression" && identifier.parent.property.type === "Identifier" ? identifier.parent.property : null;
                })
              );
              for (const accessor of accessors) {
                if (rule.named === true) {
                  context.report({
                    node: accessor,
                    message: `Expected "${accessor.name}" to be imported directly.`
                  });
                  continue;
                }
                const subrule = rule.named.find(({ name }) => name.test(accessor.name));
                if (subrule && !subrule.forbidden) {
                  context.report({
                    node: accessor,
                    message: `Expected "${accessor.name}" to be imported directly.`
                  });
                }
              }
            }
          } else if (rule.default === true) {
            context.report({
              node: root,
              message: `Expected the default import.`
            });
          }
          if (Array.isArray(namedWrappers) && namedWrappers.length > 0 && rule.named === false) {
            context.report({
              node: root,
              message: `Unexpected any named imports.`
            });
          }
          if (Array.isArray(namedWrappers) && Array.isArray(rule.named)) {
            for (const { originalNode, givenNode } of namedWrappers) {
              const subrule = rule.named.find(({ name }) => name.test(originalNode.name));
              if (!subrule) {
                continue;
              }
              if (subrule.forbidden) {
                context.report({
                  node: originalNode,
                  message: `Unexpected the named import "${originalNode.name}".`
                });
                continue;
              }
              if (givenNode && givenNode.type === "Identifier") {
                if (subrule.rename === false && originalNode.name !== givenNode.name) {
                  context.report({
                    node: givenNode,
                    message: `Expected the named import to be "${originalNode.name}".`
                  });
                  continue;
                }
                const actualName = givenNode.name;
                const expectedName = normalizeIdentifierName(
                  typeof subrule.rename === "string" ? originalNode.name.replace(subrule.name, subrule.rename) : originalNode.name
                );
                if (actualName !== expectedName) {
                  context.report({
                    node: givenNode,
                    message: `Expected the named import to be "${expectedName}".`
                  });
                }
              }
            }
          }
        }
        return {
          ImportDeclaration: function(root) {
            const modulePath = String(root.source.value);
            const namespaceNode = root.specifiers.find((node) => node.type === "ImportNamespaceSpecifier");
            const defaultNode = root.specifiers.find(
              /** @return {node is import('estree').ImportDefaultSpecifier} */
              (node) => node.type === "ImportDefaultSpecifier"
            );
            const namedNodes = root.specifiers.filter(
              /** @return {node is import('estree').ImportSpecifier} */
              (node) => node.type === "ImportSpecifier"
            );
            check({
              root,
              modulePath,
              namespaceNode: namespaceNode ? namespaceNode.local : void 0,
              defaultNode: defaultNode ? defaultNode.local : void 0,
              namedWrappers: namedNodes.map((node) => ({ originalNode: node.imported, givenNode: node.local }))
            });
          },
          CallExpression: function(root) {
            if (root.callee.type !== "Identifier" || root.callee.name !== "require" || root.arguments[0].type !== "Literal") {
              return;
            }
            const modulePath = String(root.arguments[0].value);
            if (root.parent.type === "VariableDeclarator") {
              if (root.parent.id.type === "Identifier") {
                check({
                  root: root.parent,
                  modulePath,
                  defaultNode: root.parent.id
                });
              }
              if (root.parent.id.type === "ObjectPattern") {
                check({
                  root: root.parent,
                  modulePath,
                  namedWrappers: _.compact(root.parent.id.properties.map(
                    (node) => node.type === "Property" && node.key.type === "Identifier" && node.value.type === "Identifier" ? { originalNode: node.key, givenNode: node.value } : null
                  ))
                });
              }
            }
            if (root.parent.type === "MemberExpression" && root.parent.property.type === "Identifier") {
              if (root.parent.parent.type === "VariableDeclarator" && root.parent.parent.id.type === "Identifier") {
                check({
                  root: root.parent,
                  modulePath,
                  namedWrappers: [{ originalNode: root.parent.property, givenNode: root.parent.parent.id }]
                });
              } else {
                check({
                  root: root.parent,
                  modulePath,
                  namedWrappers: [{ originalNode: root.parent.property }]
                });
              }
            }
          }
        };
      },
      tests: void 0
    };
    var findType = _.memoize(
      /**
       * @param {string} moduleName
       * @param {string} workingDirectoryPath
       * @return {string | null}
       */
      (moduleName, workingDirectoryPath) => {
        const ts = require("typescript");
        const typeDefinitionPath = (() => {
          const directoryParts = _.trim(workingDirectoryPath, fp.sep).split(/\\|\//g);
          for (let index = directoryParts.length; index > 1; index--) {
            const basePath = directoryParts.slice(0, index);
            const directModulePath = fp.join(...basePath, "node_modules", moduleName);
            if (fs.existsSync(directModulePath) && fs.lstatSync(directModulePath).isDirectory()) {
              const packagePath = fp.join(directModulePath, "package.json");
              if (fs.existsSync(packagePath)) {
                const packageJson = require(packagePath);
                if (typeof packageJson.types === "string") {
                  return fp.resolve(directModulePath, packageJson.types);
                }
                if (typeof packageJson.typings === "string") {
                  return fp.resolve(directModulePath, packageJson.typings);
                }
              }
            }
            const typeModulePath = fp.join(...basePath, "node_modules", "@types", moduleName);
            if (fs.existsSync(typeModulePath) && fs.lstatSync(typeModulePath).isDirectory()) {
              return fp.join(typeModulePath, "index.d.ts");
            }
          }
        })();
        if (!typeDefinitionPath) {
          return null;
        }
        const root = ts.createSourceFile(typeDefinitionPath, fs.readFileSync(typeDefinitionPath, "utf-8"), ts.ScriptTarget.Latest);
        const scopedModules = _.compact(
          root.statements.map(
            (node) => ts.isModuleDeclaration(node) && node.body && ts.isModuleBlock(node.body) ? node.body : null
          )
        );
        const statements = root.statements.concat(...scopedModules.map((node) => node.statements));
        for (const node of statements) {
          if (ts.isExportAssignment(node) && ts.isIdentifier(node.expression) && typeof node.expression.escapedText === "string") {
            return node.expression.escapedText;
          }
        }
        for (const node of statements) {
          if (ts.isNamespaceExportDeclaration(node) && ts.isIdentifier(node.name) && typeof node.name.escapedText === "string") {
            return node.name.escapedText;
          }
        }
        return null;
      },
      (...params) => params.join("|")
    );
    function normalizeIdentifierName(name) {
      return name.trim().replace(/^\d+/, "").split(/-/g).map((word, index) => index === 0 ? word : _.upperFirst(word)).join("");
    }
  }
});

// rules/import-path-from-closest-index.js
var require_import_path_from_closest_index = __commonJS({
  "rules/import-path-from-closest-index.js"(exports2, module2) {
    var _ = require("lodash");
    var fs = require("fs");
    var fp = require("path");
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce writing an import path pointing to the closest index file"
        }
      },
      create: function(context) {
        return {
          ImportDeclaration: function(root) {
            const importRelativePath = String(root.source.value);
            if (importRelativePath.startsWith(".") === false) {
              return null;
            }
            const currentFullPath = context.filename;
            const importFullPath = getImportFullPath(currentFullPath, importRelativePath);
            if (importFullPath === null) {
              return null;
            }
            const supportedExtensions = getSupportedExtensions(importFullPath);
            const repositoryPath = process.cwd();
            const importPartialPathFromRepository = importFullPath.substring(repositoryPath.length);
            const pathList = _.compact(importPartialPathFromRepository.split(/\\|\//));
            for (let count = 1; count <= pathList.length; count++) {
              const workPath = pathList.slice(0, count).join(fp.sep);
              for (const extension of supportedExtensions) {
                const indexFullPath = fp.join(repositoryPath, workPath, "index" + extension);
                if (fs.existsSync(indexFullPath)) {
                  if (currentFullPath.startsWith(fp.dirname(indexFullPath))) {
                    return null;
                  }
                  if (indexFullPath !== importFullPath) {
                    const unixPath = _.trim(indexFullPath.substring(repositoryPath.length).replace(/\\/, "/"), "/");
                    return context.report({
                      node: root.source,
                      message: `Expected to import "${unixPath}".`
                    });
                  }
                  break;
                }
              }
            }
          }
        };
      },
      getSupportedExtensions,
      getImportFullPath
    };
    function getSupportedExtensions(currentFullPath) {
      return fp.extname(currentFullPath) === ".ts" ? [".ts", ".tsx", ".js", ".jsx"] : [".js", ".jsx", ".ts", ".tsx"];
    }
    function getImportFullPath(currentFullPath, importRelativePath) {
      const supportedExtensions = getSupportedExtensions(currentFullPath);
      const fullPath = fp.resolve(fp.dirname(currentFullPath), importRelativePath);
      if (fp.extname(fullPath) === "") {
        for (const extension of supportedExtensions) {
          if (fs.existsSync(fullPath + extension)) {
            return fullPath + extension;
          }
        }
      }
      if (fs.existsSync(fullPath)) {
        if (fs.lstatSync(fullPath).isDirectory()) {
          for (const extension of supportedExtensions) {
            const actualPath = fp.join(fullPath, "index" + extension);
            if (fs.existsSync(actualPath)) {
              return actualPath;
            }
          }
        } else {
          return fullPath;
        }
      }
      return null;
    }
  }
});

// rules/import-name-after-file-name.js
var require_import_name_after_file_name = __commonJS({
  "rules/import-name-after-file-name.js"(exports2, module2) {
    var fp = require("path");
    var _ = require("lodash");
    var { getImportFullPath } = require_import_path_from_closest_index();
    var { singular } = require("pluralize");
    var validIdentifierPattern = /^[A-Z_$][0-9A-Z_$]*$/i;
    var acronym = /^(https?|xhr|html|xml|yml|url|pwa|io|ui|api|sdk)$/i;
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce naming a default imported identifier after the file or the directory name (for an index file)"
        },
        schema: [
          { type: "string" }
        ]
      },
      create: function(context) {
        const stripper = new RegExp(context.options[0] || "");
        const takenNames = /* @__PURE__ */ new Set();
        const reports = [];
        return {
          Program: function(root) {
            _.chain(root.body).flatMap((node) => {
              if (node.type === "ExportNamedDeclaration" && node.declaration) {
                return context.sourceCode.getDeclaredVariables(node.declaration);
              }
              if (node.type === "ExportDefaultDeclaration" && node.declaration) {
                const declaration = (
                  /** @type {any} */
                  node.declaration
                );
                return context.sourceCode.getDeclaredVariables(declaration);
              }
              return context.sourceCode.getDeclaredVariables(node);
            }).map((variable) => variable.name).compact().value().forEach((name) => {
              takenNames.add(name);
            });
          },
          ImportDeclaration: function(root) {
            if (!root.specifiers || root.specifiers.length === 0) {
              return;
            }
            const workPath = String(root.source.value);
            if (workPath.startsWith(".") === false) {
              return;
            }
            const workNode = root.specifiers.find((node) => node.type === "ImportNamespaceSpecifier" || node.type === "ImportDefaultSpecifier");
            if (workNode === void 0) {
              return;
            }
            const absoluteFilePath = getImportFullPath(context.filename, workPath) || workPath;
            const strippedFileName = fp.basename(absoluteFilePath).replace(stripper, "").replace(/\..+/, "");
            const strippedDirectoryName = fp.basename(fp.dirname(absoluteFilePath)).replace(stripper, "");
            const expectedNames = _.uniq(_.compact((() => {
              if (strippedFileName === "index") {
                const _DirectoryName = upperAllIfAcronym(upperEach(noLeadingDigits(strippedDirectoryName)));
                return [_DirectoryName];
              }
              const _fileName = validIdentifierPattern.test(strippedFileName) ? strippedFileName : upperSecond(noLeadingDigits(strippedFileName));
              if (workNode.type === "ImportNamespaceSpecifier") {
                const _FileName = _.upperFirst(_fileName);
                const _CombinedName = upperEach(singular(strippedDirectoryName) + "/" + upperAllIfAcronym(strippedFileName));
                return [_FileName, _CombinedName];
              }
              return [_fileName];
            })()));
            if (expectedNames.some((name) => takenNames.has(name))) {
              return;
            }
            if (expectedNames.every((expectedName) => expectedName !== workNode.local.name)) {
              reports.push({
                node: workNode.local,
                expectedNames
              });
            }
          },
          "Program:exit": function() {
            const expectedNameToReportedNodes = {};
            for (const { node, expectedNames } of reports) {
              for (const name of expectedNames) {
                const nodes = expectedNameToReportedNodes[name] || [];
                nodes.push(node);
                expectedNameToReportedNodes[name] = nodes;
              }
            }
            for (const { node, expectedNames } of reports) {
              const nonConflictingExpectedNames = expectedNames.filter((name) => expectedNameToReportedNodes[name].length === 1);
              if (nonConflictingExpectedNames.length === 0) {
                return;
              }
              context.report({
                node,
                message: `Expected "${node.name}" to be "${nonConflictingExpectedNames.join('" or "')}"`
              });
            }
          }
        };
      },
      tests: void 0
    };
    function upperEach(text) {
      return _.words(text).map((word) => _.upperFirst(word)).join("");
    }
    function upperSecond(text) {
      return _.words(text).map((word, rank) => rank === 0 ? _.toLower(word) : _.upperFirst(word)).join("");
    }
    function upperAllIfAcronym(text) {
      const single = singular(text);
      if (acronym.test(single)) {
        return _.toUpper(single) + text.substring(single.length);
      }
      return text;
    }
    var digitOnly = /^\d+$/;
    function noLeadingDigits(text) {
      return _.dropWhile(_.words(text), (word) => digitOnly.test(word)).join("-");
    }
  }
});

// rules/import-path-without-mentioning-index.js
var require_import_path_without_mentioning_index = __commonJS({
  "rules/import-path-without-mentioning-index.js"(exports2, module2) {
    var INDEX = /\/index(\.\w+)?$/;
    var INDEX_INTERNAL = /^\.\.?(\/\.\.)*\/index/;
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: 'enforce writing an import path to an index file without mentioning "index.js"'
        },
        fixable: "code"
      },
      create: function(context) {
        return {
          ImportDeclaration: function(root) {
            const path = root.source.value;
            const quote = root.source.raw?.charAt(0);
            if (typeof path === "string" && path.startsWith(".") && typeof quote === "string" && INDEX.test(path) && INDEX_INTERNAL.test(path) === false) {
              const expectedPath = path.replace(INDEX, "");
              return context.report({
                node: root.source,
                message: `Expected "${path}" to be "${expectedPath}".`,
                fix: (fixer) => fixer.replaceText(root.source, quote + expectedPath + quote)
              });
            }
          }
        };
      },
      tests: void 0
    };
  }
});

// rules/no-shortened-identifier.js
var require_no_shortened_identifier = __commonJS({
  "rules/no-shortened-identifier.js"(exports2, module2) {
    var _ = require("lodash");
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce naming an identifier without the user-defined abbreviations"
        },
        schema: [
          {
            type: "object"
          }
        ],
        hasSuggestions: true
      },
      create: function(context) {
        const bannedHash = context.options[0];
        if (_.isEmpty(bannedHash)) {
          return {};
        }
        return {
          FunctionDeclaration: checkFunctionLike,
          FunctionExpression: checkFunctionLike,
          ArrowFunctionExpression: checkFunctionLike,
          VariableDeclarator: function(root) {
            if ("name" in root.id) {
              check(root.id);
            }
          },
          TSTypeAliasDeclaration: function(root) {
            check(root.id);
          },
          TSEnumDeclaration: function(root) {
            check(root.id);
          }
        };
        function checkFunctionLike(root) {
          check(root.id);
          for (const node of root.params) {
            if ("name" in node) {
              check(node);
            }
          }
        }
        function check(node) {
          if (!node) {
            return;
          }
          const words = _.words(node.name).map((word) => {
            const bannedWord = bannedHash[word.toLowerCase()];
            const suggestedWord = sameCase(word, bannedWord);
            return { word, suggestedWord };
          });
          if (words.every(({ suggestedWord }) => suggestedWord === void 0)) {
            return;
          }
          context.report({
            node,
            message: "Unexpected the abbreviation " + words.filter(({ suggestedWord }) => suggestedWord !== void 0).map(({ word }) => '"' + word + '"').join(", ") + (words.length === 1 ? "" : ` as in \`${node.name}\``),
            suggest: (() => {
              if (words.some(({ suggestedWord }) => typeof suggestedWord === "string" && (suggestedWord.trim().length === 0 || suggestedWord.includes(" ")))) {
                return void 0;
              }
              let suggestedName = "";
              let traversedIndex = 0;
              for (const { word, suggestedWord } of words) {
                const wordStartingIndex = node.name.indexOf(word, traversedIndex);
                const originalPortion = node.name.substring(traversedIndex, wordStartingIndex + word.length);
                if (suggestedWord) {
                  suggestedName += node.name.substring(traversedIndex, wordStartingIndex) + suggestedWord;
                } else {
                  suggestedName += originalPortion;
                }
                traversedIndex += originalPortion.length;
              }
              if (traversedIndex < node.name.length) {
                suggestedName += node.name.substring(traversedIndex);
              }
              const optionalTypeAnnotation = "typeAnnotation" in node && node.typeAnnotation ? context.sourceCode.getText(
                /** @type {import('estree').Node} */
                node.typeAnnotation
              ) : "";
              return [{
                desc: `Did you mean "${suggestedName}"?`,
                fix: (fixer) => fixer.replaceText(node, suggestedName + optionalTypeAnnotation)
              }];
            })()
          });
        }
      },
      tests: void 0
    };
    function sameCase(referenceWord, word) {
      if (word === void 0) {
        return void 0;
      }
      if (referenceWord.toLowerCase() === referenceWord) {
        return word.toLowerCase();
      } else if (referenceWord.toUpperCase() === referenceWord) {
        return word.toUpperCase();
      } else if (_.upperFirst(referenceWord) === referenceWord) {
        return _.upperFirst(word);
      }
      return word;
    }
  }
});

// rules/no-top-level-require.js
var require_no_top_level_require = __commonJS({
  "rules/no-top-level-require.js"(exports2, module2) {
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce writing no top-level `require`"
        }
      },
      create: function(context) {
        return {
          CallExpression: function(root) {
            if (root.callee.type !== "Identifier" || root.callee.name !== "require" || root.arguments.length < 1 || root.arguments[0].type !== "Literal") {
              return;
            }
            for (const node of context.sourceCode.getAncestors(root).reverse()) {
              if (node.type === "BlockStatement" || node.type === "ArrowFunctionExpression" || node.type === "ClassBody" || node.type === "TemplateLiteral") {
                return;
              }
            }
            context.report({
              node: root,
              message: "Expected `require` to be `import` syntax"
            });
          }
        };
      },
      tests: void 0
    };
  }
});

// rules/promise-all-with-static-array.js
var require_promise_all_with_static_array = __commonJS({
  "rules/promise-all-with-static-array.js"(exports2, module2) {
    var _ = require("lodash");
    module2.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "enforce passing a static array to `Promise.all()`"
        },
        messages: {
          error: "Expected `Promise.all()` to have a argument of a static array."
        }
      },
      create: function(context) {
        return {
          CallExpression: function(root) {
            if ((root.callee.type === "MemberExpression" && root.callee.object.type === "Identifier" && root.callee.object.name === "Promise" && root.callee.property.type === "Identifier" && root.callee.property.name === "all" && root.arguments.length > 0) === false) {
              return;
            }
            const firstArgument = root.arguments[0];
            if (firstArgument.type !== "ArrayExpression" || firstArgument.elements.some((node) => node?.type === "SpreadElement")) {
              context.report({
                node: firstArgument,
                messageId: "error"
              });
            }
          }
        };
      },
      tests: void 0
    };
  }
});

// rules/react-export-default.js
var require_react_export_default = __commonJS({
  "rules/react-export-default.js"(exports2, module2) {
    var fp = require("path");
    var _ = require("lodash");
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce writing React components consistently"
        },
        fixable: "code"
      },
      create: function(context) {
        const componentName = _.startCase(
          fp.basename(context.filename).replace(/\..+/, "")
        ).replace(/\s/g, "");
        let defaultExportNode = null;
        let topLevelDeclarations = [];
        let primaryComponentNode = null;
        let primaryComponentIsUsed = false;
        function setIfPrimaryComponentIsUsed(root) {
          if (root.name !== componentName) {
            return;
          }
          if (defaultExportNode) {
            let node = root.parent;
            while (node) {
              if (node === defaultExportNode) {
                primaryComponentIsUsed = true;
                break;
              }
              node = node.parent;
            }
          }
        }
        return {
          Program: function(root) {
            defaultExportNode = root.body.find((node) => node.type === "ExportDefaultDeclaration");
            const reactImport = root.body.reduce(
              (output, node) => {
                if (node.type === "ImportDeclaration" && node.source.type === "Literal" && node.source.value === "react" && node.specifiers.length > 0) {
                  return {
                    Default: node.specifiers.find(
                      (specifier) => _.isMatch(specifier, { type: "ImportDefaultSpecifier" })
                    )?.local.name,
                    Component: node.specifiers.find(
                      (specifier) => _.isMatch(specifier, { type: "ImportSpecifier", imported: { type: "Identifier", name: "Component" } })
                    )?.local.name,
                    PureComponent: node.specifiers.find(
                      (specifier) => _.isMatch(specifier, { type: "ImportSpecifier", imported: { type: "Identifier", name: "PureComponent" } })
                    )?.local.name
                  };
                } else if (node.type === "VariableDeclaration") {
                  for (const stub of node.declarations) {
                    if (_.isMatch(stub, { type: "VariableDeclarator", init: { type: "CallExpression", callee: { type: "Identifier", name: "require" }, arguments: [{ type: "Literal", value: "react" }] } })) {
                      if (stub.id.type === "Identifier") {
                        output.Default = stub.id.name;
                      } else if (stub.id.type === "ObjectPattern") {
                        for (const propertyNode of stub.id.properties) {
                          if (propertyNode.type === "Property" && propertyNode.key.type === "Identifier" && propertyNode.value.type === "Identifier") {
                            if (propertyNode.key.name === "Component") {
                              output.Component = propertyNode.value.name;
                            } else if (propertyNode.key.name === "PureComponent") {
                              output.PureComponent = propertyNode.value.name;
                            }
                          }
                        }
                      }
                    }
                  }
                }
                return output;
              },
              /** @type {Partial<{ Default: string, Component: string, PureComponent: string }>} */
              {}
            );
            topLevelDeclarations = _.chain(root.body).map(
              /** @return {import('estree').Node} */
              (node) => {
                if ((node.type === "ExportDefaultDeclaration" || node.type === "ExportNamedDeclaration") && node.declaration) {
                  return (
                    /** @type {import('estree').Node} */
                    node.declaration
                  );
                }
                return node;
              }
            ).flatMap((node) => context.sourceCode.getDeclaredVariables(node)).flatMap(({ name, defs }) => defs.map(({ type, node }) => ({ name, type, node }))).uniqBy((definition) => definition.node).value();
            for (const { name, type, node } of topLevelDeclarations) {
              if (name === componentName) {
                if (type === "FunctionName") {
                  primaryComponentNode = node;
                }
                if (type === "ClassName" && node.type === "ClassDeclaration" && node.superClass && // Match `class ... extends React.[Component|PureComponent]`
                (reactImport.Default && _.isMatch(node.superClass, { type: "MemberExpression", object: { type: "Identifier", name: reactImport.Default }, property: { type: "Identifier" } }) && (node.superClass.property.name === "Component" || node.superClass.property.name === "PureComponent") || // Match `class ... extends Component`
                reactImport.Component && _.isMatch(node.superClass, { type: "Identifier", name: reactImport.Component }) || // Match `class ... extends PureComponent`
                reactImport.PureComponent && _.isMatch(node.superClass, { type: "Identifier", name: reactImport.PureComponent }))) {
                  primaryComponentNode = node;
                }
                if (type === "Variable") {
                  primaryComponentNode = node;
                }
              }
              if (type === "Variable") {
                if (node.init && (node.init.type === "ArrowFunctionExpression" || node.init.type === "FunctionExpression") && isReactFunctionalComponent(node.init)) {
                  context.report({
                    node,
                    message: "Expected the React component to be written as `function " + name + "(props) {...}`"
                  });
                }
              }
            }
          },
          Identifier: function(root) {
            if (_.isMatch(root.parent, { type: "CallExpression", arguments: [root] })) {
              setIfPrimaryComponentIsUsed(root);
            }
          },
          JSXIdentifier: setIfPrimaryComponentIsUsed,
          FunctionExpression: function(root) {
            if (!isReactFunctionalComponent(root)) {
              return;
            }
            if (root.parent && root.parent.type === "CallExpression" && root.parent.arguments.includes(root)) {
              context.report({
                node: root,
                message: "Expected a React component argument to be written as an arrow function"
              });
            }
          },
          "Program:exit": function(root) {
            const firstToken = context.sourceCode.getFirstToken(root);
            if (!firstToken) {
              return;
            }
            if (!primaryComponentNode) {
              return context.report({
                loc: firstToken.loc,
                message: `Expected to have a React component named "${componentName}"`
              });
            }
            const componentToken = context.sourceCode.getFirstToken(primaryComponentNode);
            if (!defaultExportNode && componentToken) {
              return context.report({
                loc: componentToken.loc,
                message: "Expected `export default` to be here"
              });
            }
            if (defaultExportNode.declaration === primaryComponentNode) {
              return;
            }
            if (defaultExportNode.declaration.type === "Identifier" && defaultExportNode.declaration.name === componentName && primaryComponentNode.type !== "VariableDeclarator" && componentToken) {
              return context.report({
                loc: componentToken.loc,
                message: "Expected `export default` to be here",
                fix: primaryComponentNode.parent.type === "ExportNamedDeclaration" ? void 0 : (fixer) => [
                  fixer.insertTextBefore(primaryComponentNode, "export default "),
                  fixer.removeRange(defaultExportNode.range)
                ]
              });
            }
            if (!primaryComponentIsUsed) {
              context.report({
                node: defaultExportNode.declaration,
                message: `Expected an enhanced component to render the React component named "${componentName}"`
              });
            }
            if (defaultExportNode.declaration.type === "FunctionDeclaration" || defaultExportNode.declaration.type === "ClassDeclaration") {
              context.report({
                node: defaultExportNode.declaration,
                message: `Expected an enhanced component to be written as an arrow function`
              });
            }
            if (defaultExportNode.declaration.type === "ArrowFunctionExpression" && defaultExportNode.declaration.body.type === "BlockStatement" && defaultExportNode.declaration.body.body.length === 1 && defaultExportNode.declaration.body.body[0].type === "ReturnStatement") {
              context.report({
                node: defaultExportNode.declaration.body.body[0],
                message: "Expected the arrow function to return the value by using the shorthand syntax"
              });
            }
          }
        };
      },
      tests: void 0
    };
    function isReactFunctionalComponent(node) {
      if (!node) {
        return false;
      }
      if (node.type === "ArrowFunctionExpression" && node.expression) {
        const type = (
          /** @type {string} */
          node.body.type
        );
        return type === "JSXElement" || type === "JSXFragment";
      }
      return node.body && node.body.type === "BlockStatement" && node.body.body.some(
        (stub) => stub.type === "ReturnStatement" && stub.argument && /** @type {string} */
        (stub.argument.type === "JSXElement" || /** @type {string} */
        stub.argument.type === "JSXFragment")
      );
    }
  }
});

// rules/react-prop-type.js
var require_react_prop_type = __commonJS({
  "rules/react-prop-type.js"(exports2, module2) {
    module2.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "enforce writing type definition for React props"
        }
      },
      create: function(context) {
        function check(root) {
          const parentNodes = context.sourceCode.getAncestors(root);
          const lastParentNode = parentNodes.at(-1);
          if (root.type === "FunctionExpression" && lastParentNode && lastParentNode.type === "MethodDefinition" && lastParentNode.key.type === "Identifier" && lastParentNode.key.name === "constructor") {
            return;
          }
          if (parentNodes.some(
            (node) => node.type === "CallExpression" && node.callee.type === "Identifier" && node.callee.name === "compose"
          )) {
            return;
          }
          if (parentNodes.some(
            (node) => node.type === "VariableDeclarator" && node.id.type === "Identifier" && node.id.name === "enhance"
          )) {
            return;
          }
          if (root.params.length > 0 && root.params[0].type === "Identifier" && root.params[0].name === "props" && (!("typeAnnotation" in root.params[0]) || !root.params[0].typeAnnotation)) {
            return context.report({
              node: root.params[0],
              message: "Expected to have type definition"
            });
          }
        }
        return {
          FunctionDeclaration: check,
          FunctionExpression: check,
          ArrowFunctionExpression: check
        };
      },
      tests: void 0
    };
  }
});

// rules/react-sort-props.js
var require_react_sort_props = __commonJS({
  "rules/react-sort-props.js"(exports2, module2) {
    var _ = require("lodash");
    var DEFAULT_PROPS_ORDER = [
      "key",
      "ref",
      "id",
      "className",
      "*ClassName",
      "*",
      "children",
      "on*",
      "data-*"
    ];
    module2.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "enforce consistent React props sorting"
        },
        schema: [
          {
            type: "array",
            items: {
              type: "string"
            }
          }
        ],
        fixable: "code"
      },
      create: function(context) {
        const matchers = (context.options[0] || DEFAULT_PROPS_ORDER).map(
          (pattern) => pattern === "*" ? null : new RegExp("^" + pattern.replace(/\*/g, ".+") + "$")
        );
        const wholeFileText = context.sourceCode.getText();
        const propTypeAnnotatedNodes = /* @__PURE__ */ new Set();
        return {
          /**
           * @param {WithParent<import('@typescript-eslint/types').TSESTree.TSTypeLiteral>} root
           */
          TSTypeLiteral: function(root) {
            if (!findPropTypeDeclaration(root.parent)) {
              return;
            }
            for (const props of getPropSegments(root.members)) {
              check(props);
            }
          },
          /**
           * @param {import('@typescript-eslint/types').TSESTree.JSXOpeningElement} root
           */
          JSXOpeningElement: function(root) {
            for (const props of getPropSegments(root.attributes)) {
              check(props);
            }
          },
          ImportDeclaration: function(root) {
            if (root.source.type !== "Literal" || root.source.value !== "react") {
              return;
            }
            function findDeclarativeNode(node) {
              if (!node) {
                return null;
              }
              if (node.type === "TSAsExpression") {
                return node;
              }
              if (node.type === "TSTypeAnnotation") {
                if ("typeAnnotation" in node.parent && node.parent.typeAnnotation === node && (node.parent.parent.type === "VariableDeclarator" || node.parent.parent.type === "AssignmentPattern" && node.parent.parent.left === node.parent)) {
                  return node.parent.parent;
                }
                if ((node.parent.type === "ArrowFunctionExpression" || node.parent.type === "FunctionDeclaration" || node.parent.type === "FunctionExpression") && node.parent.returnType === node) {
                  return node.parent;
                }
                return null;
              }
              return findDeclarativeNode(node.parent);
            }
            const defaultImportNode = root.specifiers.find((node) => node.type === "ImportDefaultSpecifier");
            if (defaultImportNode) {
              const [{ references }] = context.sourceCode.getDeclaredVariables(defaultImportNode);
              const nodes = _.chain(references).filter(
                ({ identifier }) => _.isMatch(identifier, {
                  parent: {
                    type: "TSQualifiedName",
                    left: _.pick(identifier, ["type", "name"]),
                    right: { type: "Identifier", name: "ComponentProps" },
                    parent: { type: "TSTypeReference" }
                  }
                })
              ).map((reference) => {
                const identifier = (
                  /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */
                  reference.identifier
                );
                return findDeclarativeNode(identifier.parent?.parent?.parent);
              }).compact().value();
              for (const node of nodes) {
                propTypeAnnotatedNodes.add(node);
              }
            }
            const componentTypeNode = root.specifiers.find((node) => _.isMatch(node, { type: "ImportSpecifier", imported: { type: "Identifier", name: "ComponentProps" } }));
            if (componentTypeNode) {
              const [{ references }] = context.sourceCode.getDeclaredVariables(componentTypeNode);
              const nodes = _.chain(references).filter(
                ({ identifier }) => _.isMatch(identifier, {
                  parent: {
                    type: "TSTypeReference",
                    typeName: _.pick(identifier, ["type", "name"])
                  }
                })
              ).map((reference) => {
                const identifier = (
                  /** @type {WithParent<import('@typescript-eslint/types').TSESTree.Identifier>} */
                  reference.identifier
                );
                return findDeclarativeNode(identifier.parent.parent);
              }).compact().value();
              for (const node of nodes) {
                propTypeAnnotatedNodes.add(node);
              }
            }
          },
          /**
           * @param {WithParent<import('@typescript-eslint/types').TSESTree.ObjectExpression>} root
           */
          ObjectExpression: function(root) {
            function findDeclarativeNode(node2) {
              if (!node2) {
                return null;
              }
              if (node2.type === "Property") {
                return null;
              }
              if (node2.type === "TSAsExpression") {
                return node2;
              }
              if (node2.type === "VariableDeclarator" || node2.type === "AssignmentPattern") {
                return node2;
              }
              if (node2.type === "BlockStatement") {
                return null;
              }
              if (node2.type === "ArrowFunctionExpression") {
                return node2;
              }
              if (node2.type === "ReturnStatement" && node2.parent.type === "BlockStatement" && (node2.parent.parent.type === "ArrowFunctionExpression" || node2.parent.parent.type === "FunctionDeclaration" || node2.parent.parent.type === "FunctionExpression")) {
                return node2.parent.parent;
              }
              return findDeclarativeNode(node2.parent);
            }
            const node = findDeclarativeNode(root);
            if (node && propTypeAnnotatedNodes.has(node)) {
              for (const props of getPropSegments(root.properties)) {
                check(props);
              }
            }
          }
        };
        function findIndex(name) {
          let starIndex = matchers.indexOf(null);
          if (starIndex === -1) {
            starIndex = Infinity;
          }
          let matchingIndex = -1;
          for (let index = 0; index < matchers.length; index++) {
            if (matchers[index]?.test(name)) {
              matchingIndex = index;
              break;
            }
          }
          return matchingIndex >= 0 ? matchingIndex : starIndex;
        }
        function check(props) {
          const originalNames = _.keys(props);
          if (originalNames.length === 0) {
            return;
          }
          const sortedNames = _.sortBy(originalNames, findIndex);
          const takenComments = /* @__PURE__ */ new Set();
          const surroundingCommentMap = /* @__PURE__ */ new Map();
          for (const node of _.values(props)) {
            const aboveComments = context.sourceCode.getCommentsBefore(
              /** @type {import('estree').Node} */
              node
            ).filter((comment) => !takenComments.has(comment));
            for (const comment of aboveComments) {
              takenComments.add(comment);
            }
            const rightComment = context.sourceCode.getCommentsAfter(
              /** @type {import('estree').Node} */
              node
            ).find(
              (comment) => comment.type === "Line" && comment.loc?.start.line === node.loc.end.line
            );
            if (rightComment) {
              takenComments.add(rightComment);
            }
            surroundingCommentMap.set(node, { aboveComments, rightComment });
          }
          function getNodeRangeWithComments(node) {
            const { aboveComments, rightComment } = surroundingCommentMap.get(node);
            return [
              aboveComments.length > 0 ? aboveComments[0].range[0] : node.range[0],
              rightComment ? rightComment.range[1] : node.range[1]
            ];
          }
          for (let index = 0; index < originalNames.length; index++) {
            if (originalNames[index] !== sortedNames[index]) {
              const foundNode = props[originalNames[index]];
              const expectedName = sortedNames[index];
              context.report({
                loc: foundNode.loc,
                message: `Expected the prop \`${expectedName}\` to be sorted here`,
                fix: (fixer) => _.chain(props).values().map((originalNode, index2) => {
                  if (originalNames[index2] === sortedNames[index2]) {
                    return null;
                  }
                  const expandedOriginalRange = getNodeRangeWithComments(originalNode);
                  const [originalSeparator] = context.sourceCode.getText(
                    /** @type {import('estree').Node} */
                    originalNode
                  ).match(/[;,]$/) || [""];
                  const replacementNode = props[sortedNames[index2]];
                  const expandedReplacementRange = getNodeRangeWithComments(replacementNode);
                  const replacementText = wholeFileText.substring(expandedReplacementRange[0], replacementNode.range[0]) + context.sourceCode.getText(
                    /** @type {import('estree').Node} */
                    replacementNode
                  ).replace(/[;,]$/, "") + originalSeparator + wholeFileText.substring(replacementNode.range[1], expandedReplacementRange[1]);
                  return fixer.replaceTextRange(expandedOriginalRange, replacementText);
                }).compact().reverse().value()
              });
              return;
            }
          }
        }
      },
      tests: void 0
    };
    function findPropTypeDeclaration(node) {
      if (!node || String(node.type) === "Program" || node.type === "ArrowFunctionExpression" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression") {
        return null;
      }
      if (node.type === "TSTypeAliasDeclaration" && node.id?.type === "Identifier" && node.id.name.endsWith("Props")) {
        return node;
      }
      if (node.type === "TSTypeAnnotation" && node.parent.type === "Identifier" && node.parent.name === "props") {
        return node;
      }
      return findPropTypeDeclaration(node.parent);
    }
    function getPropSegments(properties) {
      return properties.reduce(
        (groups, node) => {
          const name = (
            /** @return {string | undefined} */
            (() => {
              if (node.type === "JSXAttribute" && node.name.type === "JSXIdentifier") {
                return node.name.name;
              }
              if (node.type === "TSPropertySignature" && node.key.type === "Identifier") {
                return node.key.name;
              }
              if (node.type === "Property" && node.key.type === "Identifier") {
                return node.key.name;
              }
            })()
          );
          if (name) {
            if (groups.length === 0) {
              groups.push({ [name]: node });
            } else {
              groups[groups.length - 1][name] = node;
            }
          } else if (groups.length > 0) {
            groups.push({});
          }
          return groups;
        },
        /** @type {Array<Record<string, import('@typescript-eslint/types').TSESTree.Node>>} */
        []
      );
    }
  }
});

// rules/require-name-after-file-name.js
var require_require_name_after_file_name = __commonJS({
  "rules/require-name-after-file-name.js"(exports2, module2) {
    var _ = require("lodash");
    var fp = require("path");
    var glob = require("glob").sync;
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce naming an identifier after the file name of its `require` statement"
        },
        schema: [
          {
            type: "array",
            items: {
              type: "string"
            }
          }
        ]
      },
      create: function(context) {
        return {
          VariableDeclarator: function(root) {
            if (!root.init || root.init.type !== "CallExpression" || root.init.callee.type !== "Identifier" || root.init.callee.name !== "require" || root.init.arguments.length === 0) {
              return;
            }
            const firstArgument = root.init.arguments[0];
            if (firstArgument.type !== "Literal" || typeof firstArgument.value !== "string") {
              return;
            }
            const filePath = firstArgument.value.replace(/\.(c|m)?jsx?$/, "");
            if (/^\.\.?\/.+/.test(filePath) === false || root.id.type !== "Identifier") {
              return;
            }
            const actualName = root.id.name;
            const properName = _.chain(filePath.split("/")).last().camelCase().value().replace(/^\w/, (char) => char.toUpperCase());
            if (context.options.length > 0 && context.options[0].length > 0) {
              const fullPath = fp.resolve(context.filename);
              let index = -1;
              let found = false;
              while (++index < context.options[0].length) {
                const testPaths = glob(context.options[0][index]).map((item) => fp.resolve(item));
                if (testPaths.some((item) => item === fullPath)) {
                  found = true;
                  break;
                }
              }
              if (!found) {
                return;
              }
            }
            if (actualName !== properName) {
              context.report({
                node: root.id,
                message: `Expected "${actualName}" to be "${properName}".`
              });
            }
          }
        };
      },
      tests: void 0
    };
  }
});

// rules/require-name-after-predefined-name.js
var require_require_name_after_predefined_name = __commonJS({
  "rules/require-name-after-predefined-name.js"(exports2, module2) {
    var _ = require("lodash");
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce naming an identifier after the user-defined list of its `require` statement"
        },
        schema: [
          { type: "object" }
        ],
        fixable: "code"
      },
      create: function(context) {
        const ruleList = Object.entries(context.options?.[0] || []).map(([variableName, requirePath]) => {
          const matcher = requirePath.startsWith("/") ? new RegExp(requirePath.substring(1, requirePath.lastIndexOf("/"), requirePath.substring(requirePath.lastIndexOf("/") + 1))) : new RegExp("^" + _.escapeRegExp(requirePath) + "$");
          return [variableName, matcher];
        });
        return {
          VariableDeclarator: function(root) {
            if (!root.init || root.init.type !== "CallExpression" || root.init.callee.type !== "Identifier" || root.init.callee.name !== "require" || root.init.arguments.length === 0) {
              return;
            }
            const firstArgument = root.init.arguments[0];
            if (firstArgument.type !== "Literal" || typeof firstArgument.value !== "string") {
              return;
            }
            const actualVariableName = root.id.type === "Identifier" ? root.id.name : context.sourceCode.getText(root.id);
            const requirePath = firstArgument.value.replace(/\.(c|m)?jsx?$/, "");
            for (const [variableName, requirePathMatcher] of ruleList) {
              if (requirePathMatcher.test(requirePath)) {
                const expectVariableName = /\$\d/.test(variableName) ? requirePath.replace(requirePathMatcher, variableName) : variableName;
                if (expectVariableName !== actualVariableName) {
                  context.report({
                    node: root.id,
                    message: `Expected "${actualVariableName}" to be "${expectVariableName}".`,
                    fix: (fixer) => fixer.replaceText(root.id, expectVariableName)
                  });
                }
                break;
              }
            }
          }
        };
      },
      tests: void 0
    };
  }
});

// rules/sort-imports.js
var require_sort_imports = __commonJS({
  "rules/sort-imports.js"(exports2, module2) {
    var fs = require("fs");
    var _ = require("lodash");
    var getNodeAPIs = _.memoize(() => {
      const text = fs.readFileSync("node_modules/@types/node/index.d.ts", "utf-8");
      return text.match(/^\/\/\/ \<reference path="(.+?)"/gm)?.map((line) => line.match(/path="(.+?)\.d\.ts"/)?.[1]).filter(
        /** @return {name is string} */
        (name) => typeof name === "string" && name !== "globals.global"
      ) || [];
    });
    function getImportPath(node) {
      return String(node.source.value);
    }
    function countDots(path) {
      return path.match(/\.\./g)?.length || 0;
    }
    var SORT_TYPES = {
      module: [
        // See https://github.com/renke/import-sort/tree/master/packages/import-sort-style-module
        (node) => node.specifiers.length === 0 && getImportPath(node).startsWith(".") === false,
        (node) => node.specifiers.length === 0,
        (node) => (getNodeAPIs().includes(getImportPath(node)) || getImportPath(node).startsWith("node:")) && getImportPath(node).toLowerCase(),
        (node) => getImportPath(node).startsWith(".") === false && getImportPath(node).toLowerCase(),
        (node, { longestDotCount }) => {
          const currentDotCount = countDots(getImportPath(node));
          const reverseDotCount = Math.abs(currentDotCount - longestDotCount);
          return _.padStart(reverseDotCount.toString(), longestDotCount.toString().length, "0") + getImportPath(node).toLowerCase();
        }
      ],
      manta: [
        (node) => node.specifiers.length > 0 && getImportPath(node).startsWith(".") === false && (getImportPath(node).startsWith("react") ? "0" : "1") + getImportPath(node).toLowerCase(),
        (node) => node.specifiers.length > 0 && getImportPath(node).toLowerCase(),
        (node) => getImportPath(node).toLowerCase()
      ]
    };
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce sorting `import` statements. By default, this will sort according to [Renke](https://github.com/renke/import-sort/tree/master/packages/import-sort-style-module)"
        },
        schema: [
          { enum: Object.keys(SORT_TYPES) }
        ],
        fixable: "code"
      },
      create: function(context) {
        const rightComments = /* @__PURE__ */ new Map();
        const aboveComments = /* @__PURE__ */ new Map();
        return {
          Program: function(root) {
            if (root.sourceType !== "module" || root.body.length === 0) {
              return null;
            }
            const totalImportList = root.body.filter(
              /** @return {node is import('estree').ImportDeclaration} */
              (node) => node.type === "ImportDeclaration"
            );
            if (totalImportList.length === 0) {
              return null;
            }
            for (const thisNode of totalImportList) {
              rightComments.set(
                thisNode,
                context.sourceCode.getCommentsAfter(thisNode).filter((node) => node.loc?.start.line === thisNode.loc?.end.line)
              );
            }
            for (let index = 0; index < totalImportList.length; index++) {
              const thisNode = totalImportList[index];
              const prevNode = totalImportList[index - 1];
              aboveComments.set(
                thisNode,
                _.differenceWith(
                  context.sourceCode.getCommentsBefore(thisNode),
                  rightComments.get(prevNode) || [],
                  (a, b) => _.isEqual(a.loc, b.loc)
                )
              );
            }
            let workingImportList = _.clone(totalImportList);
            const longestDotCount = _.chain(totalImportList).map((node) => countDots(getImportPath(node))).max().value();
            const nestedImportList = SORT_TYPES[context.options[0] || "module"].map((rule) => {
              const pendingImportList = _.chain(workingImportList).filter((node) => !!rule(node, { longestDotCount })).sortBy((node) => rule(node, { longestDotCount })).value();
              workingImportList = _.difference(workingImportList, pendingImportList);
              return pendingImportList;
            }).filter((list) => list.length > 0);
            const sortedImportList = _.flatten(nestedImportList);
            const firstOfGroupImportList = nestedImportList.map((list) => list[0]);
            const totalMixedList = root.body.slice(
              root.body.indexOf(
                /** @type {any} */
                _.first(totalImportList)
              ),
              root.body.indexOf(
                /** @type {any} */
                _.last(totalImportList)
              ) + 1
            );
            const sortedOtherList = totalMixedList.filter((node) => node.type !== "ImportDeclaration");
            const sortedMixedList = [...sortedImportList, ...sortedOtherList];
            for (let index = 0; index < sortedMixedList.length; index++) {
              const realNode = totalMixedList[index];
              const sortNode = sortedMixedList[index];
              if (realNode === sortNode) {
                if (index === 0 || realNode.type !== "ImportDeclaration") {
                  continue;
                }
                const prevNode = sortedMixedList[index - 1];
                const workNode = sortNode;
                const lastNode2 = _.maxBy([prevNode, ...rightComments.get(prevNode) || []], (node) => node.loc?.end.line);
                const nextNode = _.minBy([workNode, ...aboveComments.get(workNode) || []], (node) => node.loc?.start.line);
                if (!lastNode2 || !lastNode2.loc || !lastNode2.range || !nextNode || !nextNode.loc || !nextNode.range) {
                  continue;
                }
                const lineDiff = nextNode.loc.start.line - lastNode2.loc.end.line;
                if (firstOfGroupImportList.includes(
                  /** @type {any} */
                  workNode
                )) {
                  if (lineDiff !== 2) {
                    const { range } = nextNode;
                    context.report({
                      node: workNode,
                      message: "Expected a blank line before this import statement.",
                      fix: (fixer) => fixer.insertTextBeforeRange(range, "\n")
                    });
                  }
                } else {
                  if (lineDiff !== 1) {
                    const range = [lastNode2.range[1], nextNode.range[0]];
                    context.report({
                      node: workNode,
                      message: "Unexpected a blank line before this import statement.",
                      fix: (fixer) => fixer.replaceTextRange(range, "\n")
                    });
                  }
                }
                continue;
              }
              const [reportedNode, reportedMessage] = (() => {
                if (realNode.type === "ImportDeclaration") {
                  const expectedIndex = sortedMixedList.indexOf(realNode);
                  const referenceNode = sortedMixedList[expectedIndex - 1];
                  return [
                    realNode,
                    `Expected this import statement to be placed after ${referenceNode.type === "ImportDeclaration" ? `"${getImportPath(referenceNode)}"` : context.sourceCode.getText(referenceNode)}.`
                  ];
                } else {
                  return [
                    /** @type {import('estree').ImportDeclaration} */
                    totalMixedList.slice(index).find((node) => node.type === "ImportDeclaration"),
                    "Expected import statements to be placed consecutively."
                  ];
                }
              })();
              const firstNode = totalMixedList[0];
              const lastNode = totalMixedList[totalMixedList.length - 1];
              return context.report({
                node: reportedNode,
                message: reportedMessage,
                fix: (fixer) => fixer.replaceTextRange(
                  [
                    _.chain([
                      firstNode,
                      ...aboveComments.get(firstNode) || []
                    ]).map((node) => node.range?.[0]).min().value(),
                    _.chain([lastNode, ...rightComments.get(lastNode) || []]).map((node) => node.range?.[1]).max().value()
                  ],
                  (nestedImportList.map(
                    (list) => [
                      "",
                      ...list.map((node) => (aboveComments.get(node)?.map((node2) => context.sourceCode.getText(
                        /** @type {any} */
                        node2
                      )).join("\n") + "\n" + context.sourceCode.getText(node) + " " + rightComments.get(node)?.map((node2) => context.sourceCode.getText(
                        /** @type {any} */
                        node2
                      )).join(" ")).trim())
                    ].join("\n")
                  ).join("\n").trim() + "\n\n" + sortedOtherList.map((node) => context.sourceCode.getText(node)).join("\n")).trim()
                )
              });
            }
            const lastImport = _.last(sortedImportList);
            if (!lastImport || !lastImport.range) {
              return;
            }
            const afterLastImport = root.body[root.body.indexOf(lastImport) + 1];
            if (!afterLastImport || !afterLastImport.range) {
              return;
            }
            const afterLastImportText = context.sourceCode.getText(afterLastImport);
            const betweenTheLines = context.sourceCode.getText(afterLastImport, afterLastImport.range[0] - lastImport.range[1]);
            const newLineCount = (betweenTheLines.substring(0, betweenTheLines.length - afterLastImportText.length).match(/\n/g) || []).length;
            if (newLineCount < 2) {
              context.report({
                node: lastImport,
                message: "Expected a blank line after the last import statement.",
                fix: (fixer) => fixer.replaceText(lastImport, context.sourceCode.getText(lastImport) + "\n")
              });
            }
          }
        };
      },
      tests: void 0
    };
  }
});

// rules/test-case-title.js
var require_test_case_title = __commonJS({
  "rules/test-case-title.js"(exports2, module2) {
    var _ = require("lodash");
    var ALLOWED_TEST_PATTERN = /^(returns|renders|calls|fetches|sets|throws|does not (return|render|call|fetch|set|throw) )/;
    var DISALLOWED_WORDS = ["proper", "correct", "appropriate", "accurate", "perfect"];
    var DISALLOWED_PATTERN = new RegExp("\\W((" + DISALLOWED_WORDS.join("|") + ")(ly)?)(\\W|$)", "i");
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: 'enforce writing consistent test case titles for `it` and `test` function calls; the allowed pattern of the test case title is `"(does not) return/render/call/fetch/set/throw(s) ... (, given ...)"`; this also disallows writing some vague words, such ' + DISALLOWED_WORDS.join(", ")
        },
        messages: {
          start: 'Expected the test case title to start with "(does not) return/render/call/fetch/set/throw(s) ... (, given ...)" only',
          vague: 'Expected the test case title to provide more details rather using the word "{{word}}"',
          direct: "Expected the description title to be the direct reference of the function (removing the string quotes)"
        }
      },
      create: function(context) {
        return {
          ExpressionStatement: function(root) {
            if (root.expression.type !== "CallExpression" || root.expression.callee.type !== "Identifier" || root.expression.arguments.length < 2) {
              return;
            }
            const functionCall = root.expression.callee.name;
            if (functionCall !== "it" && functionCall !== "test") {
              return;
            }
            const titleNode = root.expression.arguments[0];
            const titleText = getText(titleNode);
            if (typeof titleText !== "string") {
              return;
            }
            if (ALLOWED_TEST_PATTERN.test(titleText) === false) {
              return context.report({
                node: titleNode,
                messageId: "start"
              });
            }
            const bannedWord = titleText.match(DISALLOWED_PATTERN)?.[1];
            if (bannedWord) {
              return context.report({
                node: titleNode,
                messageId: "vague",
                data: {
                  word: bannedWord
                }
              });
            }
          }
        };
      },
      tests: void 0
    };
    function getText(node) {
      if (!node) {
        return void 0;
      }
      if (node.type === "Literal" && typeof node.value === "string") {
        return node.value;
      }
      if (node.type === "TemplateLiteral") {
        return _.get(node, "quasis.0.value.cooked", void 0);
      }
    }
    module2.exports.getText = getText;
  }
});

// rules/test-case-group.js
var require_test_case_group = __commonJS({
  "rules/test-case-group.js"(exports2, module2) {
    var _ = require("lodash");
    var { getText } = require_test_case_title();
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce using a function reference as a test case description"
        },
        messages: {
          unexpected: "Expected a describe title to be an object name, a namespace or a function name",
          unused: "Expected the identifier with the same name to be used inside the describe block"
        },
        fixable: "code"
      },
      create: function(context) {
        return {
          ExpressionStatement: function(root) {
            if (root.expression.type !== "CallExpression" || root.expression.callee.type !== "Identifier" || root.expression.callee.name !== "describe" || root.expression.arguments.length < 2) {
              return;
            }
            const describeNameNode = root.expression.arguments[0];
            if (!describeNameNode) {
              return;
            }
            const describeBlockNode = "body" in root.expression.arguments[1] ? root.expression.arguments[1].body : null;
            if (!describeBlockNode) {
              return;
            }
            const currentScope = context.sourceCode.getScope(describeNameNode);
            function getAllVariables(scope = currentScope) {
              if (!scope || scope.type === "global") {
                return [];
              }
              return [...scope.variables.map((variable) => variable.name), ...scope.upper ? getAllVariables(scope.upper) : []];
            }
            const targetNodes = (
              /** @return {Array<NodeLike>} */
              (() => {
                if (describeNameNode.type === "Identifier" || describeNameNode.type === "MemberExpression") {
                  return [getNodeLike(describeNameNode)];
                }
                const describeName = getText(describeNameNode);
                if (typeof describeName === "string" && describeName.trim().length > 0) {
                  const [objectName, ...propertyAccessorNames] = describeName.split(".");
                  if (propertyAccessorNames.length === 0) {
                    return [
                      { type: "Identifier", name: objectName },
                      ...getAllVariables().map((name) => ({
                        type: (
                          /** @type {const} */
                          "MemberExpression"
                        ),
                        object: { type: "Identifier", name },
                        property: { type: "Identifier", name: objectName }
                      }))
                    ];
                  }
                  return [
                    propertyAccessorNames.reduce(
                      (object, name) => ({
                        type: "MemberExpression",
                        object,
                        property: { type: "Identifier", name }
                      }),
                      /** @type {NodeLike} */
                      { type: "Identifier", name: objectName }
                    )
                  ];
                }
                return [];
              })()
            );
            if (targetNodes.length === 0) {
              return;
            }
            const describeBlockScope = context.sourceCode.getScope(describeBlockNode);
            function isUsedInDescribeBlock(scope) {
              if (scope === describeBlockScope) {
                return true;
              }
              if (!scope.upper) {
                return false;
              }
              return isUsedInDescribeBlock(scope.upper);
            }
            for (const targetNode of targetNodes) {
              const partialMatchingVariable = getVariable(currentScope, getObjectName(targetNode));
              if (!partialMatchingVariable) {
                continue;
              }
              const fullyMatchingVariables = partialMatchingVariable.references.filter((ref) => {
                if (targetNode.type === "Identifier" && _.isMatch(ref.identifier, targetNode)) {
                  return true;
                }
                return _.isMatch(getFullPropertyAccessorNode(ref.identifier), targetNode);
              });
              if (fullyMatchingVariables.length === 0) {
                continue;
              }
              if (!fullyMatchingVariables.some((ref) => isUsedInDescribeBlock(ref.from))) {
                context.report({
                  node: describeNameNode,
                  messageId: "unused"
                });
              }
              return;
            }
            context.report({
              node: describeNameNode,
              messageId: "unexpected"
            });
          }
        };
      },
      tests: void 0
    };
    function getNodeLike(node) {
      if (node.type === "MemberExpression") {
        return { type: "MemberExpression", object: getNodeLike(node.object), property: getNodeLike(node.property) };
      }
      if (node.type === "Identifier") {
        return _.pick(node, "type", "name");
      }
      return _.pick(node, "type");
    }
    function getObjectName(node) {
      if (node.type === "Identifier" && "name" in node) {
        return node.name;
      }
      if (node.type === "MemberExpression" && "object" in node) {
        return getObjectName(node.object);
      }
      return "";
    }
    function getVariable(scope, name) {
      const variable = scope.variables.find((variable2) => variable2.name === name);
      if (variable) {
        return variable;
      }
      if (!scope.upper) {
        return null;
      }
      return getVariable(scope.upper, name);
    }
    function getFullPropertyAccessorNode(node) {
      if (node.parent && node.parent.type === "MemberExpression") {
        return getFullPropertyAccessorNode(node.parent);
      }
      return node;
    }
  }
});

// rules/test-case-new-line.js
var require_test_case_new_line = __commonJS({
  "rules/test-case-new-line.js"(exports2, module2) {
    var _ = require("lodash");
    var focusedAPI = /^(it|test|describe|(after|before)(All|Each))$/;
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce having a new line between `it`, `test`, `describe` and before `expect` function calls; this applies to _*.{test,spec}_ files only"
        },
        fixable: "code"
      },
      create: function(context) {
        return {
          Program: check,
          BlockStatement: check
        };
        function check(root) {
          const nodeList = root.body.map(
            /**
             * @param {import('estree').ModuleDeclaration | import('estree').Statement | import('estree').Directive} node
             * @param {number} rank
             */
            (node, rank) => ({
              node,
              rank,
              name: node.type === "ExpressionStatement" && getLeftMostIdentifier(node.expression) || ""
            })
          );
          for (const { node, rank, name } of nodeList) {
            const prev = nodeList[rank - 1];
            const next = nodeList[rank + 1];
            const aboveBlankLineCount = prev && node.loc && prev.node.loc ? node.loc.start.line - prev.node.loc.end.line - 1 : NaN;
            const belowBlankLineCount = next && node.loc && next.node.loc ? next.node.loc.start.line - node.loc.end.line - 1 : NaN;
            if (focusedAPI.test(name)) {
              if (aboveBlankLineCount <= 0) {
                const loc = context.sourceCode.getFirstToken(node)?.loc;
                if (loc) {
                  context.report({
                    loc,
                    message: "Expected a blank line before this statement",
                    fix: (fixer) => fixer.insertTextAfter(prev.node, "\n")
                  });
                }
              }
              if (belowBlankLineCount <= 0 && !focusedAPI.test(next.name)) {
                const loc = context.sourceCode.getLastToken(node)?.loc;
                if (loc) {
                  context.report({
                    loc,
                    message: "Expected a blank line after this statement",
                    fix: (fixer) => fixer.insertTextAfter(node, "\n")
                  });
                }
              }
            }
            if (name == "expect") {
              if (aboveBlankLineCount <= 0 && prev.name !== "expect") {
                const loc = context.sourceCode.getFirstToken(node)?.loc;
                if (loc) {
                  context.report({
                    loc,
                    message: "Expected a blank line before this statement",
                    fix: (fixer) => fixer.insertTextAfter(prev.node, "\n")
                  });
                }
              } else if (aboveBlankLineCount >= 1 && prev.name === "expect" && !context.sourceCode.commentsExistBetween(prev.node, node)) {
                const loc = context.sourceCode.getFirstToken(node)?.loc;
                if (loc && prev.node.range && node.range) {
                  const range = [prev.node.range[1], node.range[0]];
                  context.report({
                    loc,
                    message: "Expected no blank line between `expect` statements",
                    fix: (fixer) => {
                      const replacement = _.get(context.sourceCode.getText().substring(range[0], range[1]).match(/\n(.*)$/), "0", "\n");
                      return fixer.replaceTextRange(range, replacement);
                    }
                  });
                }
              }
              if (belowBlankLineCount <= 0 && next.name !== "expect") {
                const loc = context.sourceCode.getLastToken(node)?.loc;
                if (loc) {
                  context.report({
                    loc,
                    message: "Expected a blank line after this statement",
                    fix: (fixer) => fixer.insertTextAfter(node, "\n")
                  });
                }
              }
            }
          }
        }
      },
      tests: void 0
    };
    function getLeftMostIdentifier(root) {
      if (!root) {
        return null;
      }
      if (root.type === "Identifier") {
        return root.name;
      }
      if (root.type === "CallExpression") {
        return getLeftMostIdentifier(root.callee);
      }
      if (root.type === "MemberExpression") {
        return getLeftMostIdentifier(root.object);
      }
      if (root.type === "AwaitExpression") {
        return getLeftMostIdentifier(root.argument);
      }
      return null;
    }
  }
});

// rules/typescript-enum-name.js
var require_typescript_enum_name = __commonJS({
  "rules/typescript-enum-name.js"(exports2, module2) {
    var _ = require("lodash");
    var STYLES = {
      PascalCase: function(input) {
        return _.upperFirst(_.camelCase(input));
      },
      camelCase: function(input) {
        return _.camelCase(input);
      },
      UPPERCASE: function(input) {
        return _.words(input).join("").toUpperCase();
      },
      SNAKE_CASE: function(input) {
        return _.snakeCase(input).toUpperCase();
      }
    };
    var options = Object.keys(STYLES);
    var defaultOption = options[0];
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce naming enumerations consistently; the possible options are " + options.map((option) => '`"' + option + '"`' + (option === defaultOption ? " (default)" : "")).join(", ")
        },
        schema: [
          {
            enum: options,
            default: defaultOption
          }
        ]
      },
      create: function(context) {
        return {
          /**
           * @param {import('@typescript-eslint/types').TSESTree.TSEnumDeclaration} root
           */
          TSEnumDeclaration: function(root) {
            if (!context.options || !STYLES[context.options[0]]) {
              return null;
            }
            const expectedName = STYLES[context.options[0]](root.id.name);
            if (root.id.name !== expectedName) {
              context.report({
                node: root.id,
                message: `Expected the enumeration to be named "${expectedName}".`
              });
            }
          }
        };
      },
      tests: void 0
    };
  }
});

// rules/typescript-explicit-return-type.js
var require_typescript_explicit_return_type = __commonJS({
  "rules/typescript-explicit-return-type.js"(exports2, module2) {
    var CONDITION = "onlyIfMoreThanOneReturns";
    module2.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "enforce writing an explicit return type for exported functions"
        },
        schema: [
          {
            enum: [null, CONDITION],
            default: null
          }
        ]
      },
      create: function(context) {
        const untypedFunctionHash = {};
        return {
          ExportNamedDeclaration: function(root) {
            if (!root.declaration) {
              return null;
            }
            if (root.declaration.type === "FunctionDeclaration" && !("returnType" in root.declaration && root.declaration.returnType) && checkForReturnViolation(root.declaration)) {
              return context.report({
                node: root.declaration,
                message: `Expected an exported function must have a return type.`
              });
            }
            if (root.declaration.type === "VariableDeclaration" && root.declaration.declarations) {
              for (const node of root.declaration.declarations) {
                if (node.type !== "VariableDeclarator") {
                  continue;
                }
                if ("typeAnnotation" in node.id && node.id.typeAnnotation) {
                  continue;
                }
                if (!node.init || node.init.type !== "ArrowFunctionExpression" && node.init.type !== "FunctionExpression") {
                  continue;
                }
                if ("returnType" in node.init && node.init.returnType) {
                  continue;
                }
                if (checkForReturnViolation(node.init)) {
                  context.report({
                    node,
                    message: `Expected an exported function must have a return type.`
                  });
                }
              }
            }
          },
          FunctionDeclaration: function(root) {
            if (root.id && root.id.type === "Identifier" && !("returnType" in root && root.returnType) && checkForReturnViolation(root)) {
              untypedFunctionHash[root.id.name] = root;
            }
          },
          VariableDeclarator: function(root) {
            if (root.id && root.id.type === "Identifier" && !("typeAnnotation" in root.id && root.id.typeAnnotation) && root.init && (root.init.type === "FunctionExpression" || root.init.type === "ArrowFunctionExpression") && !("returnType" in root.init && root.init.returnType) && checkForReturnViolation(root.init)) {
              untypedFunctionHash[root.id.name] = root.init;
            }
          },
          ExportDefaultDeclaration: function(root) {
            if (root.declaration && root.declaration.type === "Identifier" && untypedFunctionHash[root.declaration.name]) {
              context.report({
                node: untypedFunctionHash[root.declaration.name],
                message: `Expected an exported function must have a return type.`
              });
            }
          }
        };
        function checkForReturnViolation(node) {
          if (context.options[0] !== CONDITION) {
            return true;
          }
          if (node.body.type !== "BlockStatement") {
            return false;
          }
          const returnNodes = getReturnStatements(node.body);
          if (returnNodes.length === 0) {
            return false;
          }
          const mainReturnNode = node.body.body.find((node2) => node2.type === "ReturnStatement");
          const earlyReturnNodes = returnNodes.filter((node2) => node2 !== mainReturnNode);
          if (earlyReturnNodes.length === 0) {
            return false;
          }
          if (earlyReturnNodes.every(
            (node2) => !node2.argument || node2.argument.type === "Identifier" && node2.argument.name === "undefined" || node2.argument.type === "UnaryExpression" && node2.argument.operator === "void"
          )) {
            return false;
          }
          return true;
        }
      },
      tests: void 0
    };
    function getReturnStatements(node) {
      if (!node) {
        return [];
      } else if (node.type === "ReturnStatement") {
        return [node];
      } else if (node.type === "ArrowFunctionExpression" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression") {
        return [];
      }
      let results = [];
      for (const key in node) {
        if (key === "loc" || key === "range" || key == "parent") {
          continue;
        }
        if (typeof node[key] === "object") {
          results = results.concat(getReturnStatements(node[key]));
        }
      }
      return results;
    }
  }
});

// rules/typescript-exported-interface.js
var require_typescript_exported_interface = __commonJS({
  "rules/typescript-exported-interface.js"(exports2, module2) {
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce exporting an `interface`, unless it is inside a `declare` block"
        }
      },
      create: function(context) {
        return {
          TSInterfaceDeclaration: function(root) {
            if (!root.parent || root.parent.type !== "ExportNamedDeclaration") {
              if (context.sourceCode.getAncestors(root).some((node) => String(node.type) === "TSModuleDeclaration")) {
                return;
              }
              return context.report({
                node: root,
                message: `Expected interfaces to be exported.`
              });
            }
          }
        };
      },
      tests: void 0
    };
  }
});

// rules/typescript-method-type.js
var require_typescript_method_type = __commonJS({
  "rules/typescript-method-type.js"(exports2, module2) {
    var _ = require("lodash");
    module2.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "enforce writing function types using arrow notation"
        },
        fixable: "code"
      },
      create: function(context) {
        return {
          /**
           * @param {import('@typescript-eslint/types').TSESTree.TSMethodSignature} root
           */
          TSMethodSignature: function(root) {
            context.report({
              node: cast(root),
              message: "Expected to be using arrow notation",
              fix: (fixer) => fixer.replaceText(
                cast(root),
                context.sourceCode.getText(cast(root.key)) + (root.optional ? "?" : "") + ": " + (root.typeParameters ? context.sourceCode.getText(cast(root.typeParameters)) : "") + "(" + _.map(root.params, (node) => context.sourceCode.getText(cast(node))).join(
                  ", "
                ) + ") => " + (root.returnType ? context.sourceCode.getText(cast(root.returnType)).replace(/^:\s*/, "") : "void")
              )
            });
          }
        };
      },
      tests: void 0
    };
    function cast(node) {
      return node;
    }
  }
});

// index.js
module.exports = {
  meta: {
    name: "eslint-plugin-levitate"
  },
  rules: {
    "comment": require_comment(),
    "export-name-after-file-name": require_export_name_after_file_name(),
    "import-convention": require_import_convention(),
    "import-name-after-file-name": require_import_name_after_file_name(),
    "import-path-from-closest-index": require_import_path_from_closest_index(),
    "import-path-without-mentioning-index": require_import_path_without_mentioning_index(),
    "no-shortened-identifier": require_no_shortened_identifier(),
    "no-top-level-require": require_no_top_level_require(),
    "promise-all-with-static-array": require_promise_all_with_static_array(),
    "react-export-default": require_react_export_default(),
    "react-prop-type": require_react_prop_type(),
    "react-sort-props": require_react_sort_props(),
    "require-name-after-file-name": require_require_name_after_file_name(),
    "require-name-after-predefined-name": require_require_name_after_predefined_name(),
    "sort-imports": require_sort_imports(),
    "test-case-group": require_test_case_group(),
    "test-case-new-line": require_test_case_new_line(),
    "test-case-title": require_test_case_title(),
    "typescript-enum-name": require_typescript_enum_name(),
    "typescript-explicit-return-type": require_typescript_explicit_return_type(),
    "typescript-exported-interface": require_typescript_exported_interface(),
    "typescript-method-type": require_typescript_method_type()
  }
};
